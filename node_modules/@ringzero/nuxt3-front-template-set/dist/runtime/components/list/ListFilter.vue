<template>
  <table ref="filters" class="Filters">
    <tr v-for="(item, i) in headerObjects" :key="i">
      <th>{{ item.title }}</th>
      <td v-if="item.filter === FORM_ITEM.RADIO_GROUP">
        <ButtonRadioSet
          :items="item.contents"
          :inline="true"
          :value="input[item.key]"
          @update:value="onChangeRadio($event, item)"
        />
      </td>
      <td v-if="item.filter === FORM_ITEM.SELECT_CHECK">
        <ButtonCheckSet :items="input[item.key]" :inline="true" all @update:value="onChangeCheck($event, item)" />
      </td>
      <td v-if="item.filter === FORM_ITEM.INPUT">
        <FormInput :edit="true" :value="input[item.key]" medium @update:value="onChangeInput($event, item)" />
        <div class="smallButton primary ml-2 mt-0" @click="onSearch(input[item.key], item)">検索</div>
      </td>
      <td v-if="item.filter === FORM_ITEM.DATE_RANGE">
        <FormDate
          :edit="true"
          :width="130"
          :value="input[item.key + '-start']"
          medium
          @update:value="onChangeDateStart($event, item)"
        />
        <span class="mx-2">-</span>
        <FormDate
          :edit="true"
          :width="130"
          :value="input[item.key + '-end']"
          medium
          @update:value="onChangeDateEnd($event, item)"
        />
        <div
          class="smallButton primary ml-2 mt-0"
          @click="onSearchDateRange(input[item.key + '-start'], input[item.key + '-end'], item)"
        >
          絞り込み
        </div>
      </td>
      <td v-if="item.filter === FORM_ITEM.DATETIME_RANGE">日時の範囲指定</td>
      <td v-if="item.filter === FORM_ITEM.TIME_RANGE">時間の範囲指定</td>
    </tr>
  </table>
</template>

<script setup lang="ts">
/**===================================================================================================================
 *
  ===================================================================================================================**/
import { type VariableSize, type FixedSize } from '../../components/common'
import { type CheckBoxSetProps, type ToggleProps, TOGGLE_TYPE } from '../../components/common'
import { type DataTableHeader, FORM_MODE, FORM_ITEM, type formItem, type baseProps } from '../../components/common'
import { ref, watch, onBeforeMount, type Ref, onMounted, onBeforeUnmount } from 'vue'
import { useDelay } from '../../composables/utility'
import { useListFilterSetting } from '../../composables/list'
import type { ModalSwitch } from '../../types'
//------------------------------------------------------------------------------------------------------------
// 引数
//------------------------------------------------------------------------------------------------------------
interface Props {
  name: string
  switcher: ModalSwitch
  headers: DataTableHeader[]
}
const props = withDefaults(defineProps<Props>(), {})
//------------------------------------------------------------------------------------------------------------
// 定数・変数（state）
//------------------------------------------------------------------------------------------------------------
const inputHeaders = ref(props.headers)
const isReset = ref(false)
// サイズ変更＆可動ダイアログ
const filters: Ref<HTMLInputElement | undefined> = ref()

const input: Ref<{ [key: string]: any }> = ref({})
const inputSwitch = ref(props.switcher)
const filterSetting = useListFilterSetting()

interface FilterHeader {
  key: string
  title: string
  filter?: string
  contents?: any[]
}
const headerObjects: Ref<{ [key: string]: FilterHeader }> = ref({})
//------------------------------------------------------------------------------------------------------------
// ライフサイクル
//------------------------------------------------------------------------------------------------------------
onMounted(() => {
  //データが保存されていない場合、最初は全部true
  setData()
  window.addEventListener('resize', onGetPosition)
})

onBeforeUnmount(() => {
  window.removeEventListener('resize', onGetPosition)
})

//------------------------------------------------------------------------------------------------------------
//watch
//------------------------------------------------------------------------------------------------------------
watch(
  () => props.headers,
  (value) => {
    inputHeaders.value = value
    setData()
  },
  { deep: true }
)

watch(
  () => props.switcher,
  (value) => {
    if (filterSetting.value[props.name]) {
      filterSetting.value[props.name].opened = value.opened
    } else {
      filterSetting.value[props.name] = { opened: value.opened, values: undefined }
    }
  },
  { deep: true }
)

//------------------------------------------------------------------------------------------------------------
//computed
//------------------------------------------------------------------------------------------------------------
/*
  const counter: Ref<number> = useState('counter', () => 500)

  // computedによりcounter変数の監視が行われる
  const doubleCount = computed(() => {
    return counter.value * 2
  })
  */
//------------------------------------------------------------------------------------------------------------
// エミット
//------------------------------------------------------------------------------------------------------------
const emits = defineEmits<{
  (e: 'update:changeFilter', item: any): void
  (e: 'update:height', item: number): void
}>()

//------------------------------------------------------------------------------------------------------------
// メソッド
//------------------------------------------------------------------------------------------------------------

function onChangeRadio(value: any, item: any) {
  emits('update:changeFilter', { key: item.key, value: value })
  input.value[item.key] = value
  filterSetting.value[props.name].values = input.value
}

function onChangeCheck(value: any, item: any) {
  emits('update:changeFilter', { key: item.key, value: value })
  input.value[item.key] = value
  filterSetting.value[props.name].values = input.value
}

function onChangeDateStart(value: any, item: any) {
  input.value[item.key + '-start'] = value
  filterSetting.value[props.name].values = input.value
}

function onChangeDateEnd(value: any, item: any) {
  input.value[item.key + '-end'] = value
  filterSetting.value[props.name].values = input.value
}

function onChangeInput(value: any, item: any) {
  input.value[item.key] = value
  filterSetting.value[props.name].values = input.value
}

function onSearch(value: string, item: any) {
  emits('update:changeFilter', { key: item.key, value: value })
}
function onSearchDateRange(start: string, end: string, item: any) {
  emits('update:changeFilter', { key: item.key, value: [start, end] })
}

const delay = useDelay()

async function setData() {
  const saveData = filterSetting.value[props.name]
  console.log('データセット', saveData)
  inputHeaders.value?.forEach((head) => {
    if (filterCheck(head)) {
      headerObjects.value[head.key] = {
        key: head.key,
        title: head.title,
        filter: head.filter,
        contents: head.contents,
      }

      if (head.filter === FORM_ITEM.RADIO_GROUP) {
        head.contents?.forEach((item) => {
          if (item.default === true) {
            input.value[head.key] = item.value
          }
        })
      } else if (head.filter === FORM_ITEM.SELECT_CHECK) {
        const array: CheckBoxSetProps[] = []
        head.contents?.forEach((item) => {
          const saveFilter = saveData?.values[head.key]?.find((filter: any) => filter.value === item.value)
          array.push({
            text: item.text,
            value: item.value,
            checked: saveFilter ? saveFilter.checked : true,
          })
        })
        input.value[head.key] = array
      } else if (head.filter === FORM_ITEM.DATE_RANGE) {
        input.value[head.key + '-start'] = saveData?.values[head.key + '-start']
        input.value[head.key + '-end'] = saveData?.values[head.key + '-end']
      } else if (head.filter === FORM_ITEM.INPUT) {
        input.value[head.key] = saveData?.values[head.key]
      }
      // Filterのオンオフを読み込む
      emits('update:changeFilter', { key: head.key, value: input.value[head.key] })
    }
  })

  if (saveData) {
    filterSetting.value[props.name].values = input.value
  } else {
    filterSetting.value[props.name] = {
      opened: false,
      values: input.value,
    }
  }
  await delay.wait(160)
  onGetPosition()
}

function filterCheck(head: DataTableHeader) {
  let result = false
  if (head) {
    if (
      head.filter &&
      (head.type === FORM_ITEM.CHECK_GROUP ||
        head.type === FORM_ITEM.RADIO_GROUP ||
        head.type === FORM_ITEM.SELECT_CHECK ||
        head.type === FORM_ITEM.SELECT_MENU ||
        head.type === FORM_ITEM.ASSOCIATE_SELECT_MENU ||
        head.type === FORM_ITEM.ASSOCIATE_SELECT_CHECK ||
        head.type === FORM_ITEM.DATE ||
        head.type === FORM_ITEM.DATETIME ||
        head.type === FORM_ITEM.TIME ||
        head.type === FORM_ITEM.DATE_RANGE ||
        head.type === FORM_ITEM.DATETIME_RANGE ||
        head.type === FORM_ITEM.TIME_RANGE ||
        head.type === FORM_ITEM.INPUT)
    ) {
      result = true
    }
  }
  return result
}

function onGetPosition() {
  if (filters.value) {
    const h = filters.value.getBoundingClientRect().height + 10
    emits('update:height', h)
  }
}

function onClose() {}
</script>

<style scoped>
.ChoiceItems {
  position: relative;
}

.Filters {
  margin-left: 10px;
  border-spacing: 0px 6px;
}
.Filters th {
  font-size: 14px;
  padding: 6px 10px 4px 0;
  text-align: left;
  min-height: 28px;
}
.Filters td {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  padding-bottom: 0px;
  min-height: 28px;
}
</style>
