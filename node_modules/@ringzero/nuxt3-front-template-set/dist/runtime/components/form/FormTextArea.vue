<template>
  <FormBase
    class="FormInputText"
    :base="base"
    :label="label"
    :rule="rule || data?.rule"
    :min="min"
    :max="max"
    :mode="mode"
    :edit="isEdit"
    :width="width || base?.width"
    :col-width="colWidth"
    :label-width="labelWidth"
    :hint="hint"
    :hintchip="hintchip"
    :error="inputError"
    :result="result"
    :focus="focus"
    :small="small"
    :medium="medium"
  >
    <div class="FormInputContainer">
      <div v-if="prefix" class="Prefix">{{ prefix }}</div>
      <div
        class="FormInputContent"
        :style="{
          width: width ? width + 'px' : base?.width ? base.width + 'px' : '100%',
        }"
      >
        <textarea
          ref="inputItem"
          :id="props.data?.name"
          :name="props.data?.name"
          class="Input"
          :class="{
            InputError: inputError && isEdit,
            Preview: !isEdit,
          }"
          :style="{
            height: row ? row * 21 + 16 + 'px' : height ? height + 'px' : undefined,
            resize: row || height ? 'none' : 'vertical',
          }"
          :value="input"
          :placeholder="placeholder"
          @input="onChange"
          @focus="onFocus"
          @blur="onBlur"
          :disabled="!isEdit"
        ></textarea>
        <div
          class="UpperMask"
          :class="{ offLine: !isEdit }"
          :style="{ backgroundColor: !isEdit ? maskColor + ' !important' : '' }"
        />
        <div
          class="LowerMask"
          :class="{ offLine: !isEdit }"
          :style="{ backgroundColor: !isEdit ? maskColor + ' !important' : '' }"
        />
        <div v-if="!(row || height)" class="Resize" :class="{ offLine: !isEdit }">
          <v-icon :icon="ICONS.RESIZE" />
        </div>
      </div>
      <div v-if="suffix" class="Suffix">{{ suffix }}</div>
    </div>
  </FormBase>
</template>

<script setup lang="ts">
/**===================================================================================================================
   * TextArea(文字列複数行入力)
   ===================================================================================================================**/
import { FORM_MODE, type formProps, type formItem } from '../../components/common'
import { RULE, useValidation, type ruleParams } from '../../composables/validation'
import { ref, watch, type Ref } from 'vue'
import { ICONS } from '../../composables/constants'
//------------------------------------------------------------------------------------------------------------
// 引数
//------------------------------------------------------------------------------------------------------------
interface Props extends formProps {
  rule?: any
  value?: string
  height?: number
  row?: number
  maskColor?: string
  max?: number
  min?: number
}

const props = withDefaults(defineProps<Props>(), {})
//------------------------------------------------------------------------------------------------------------
// 定数・変数（state）
//------------------------------------------------------------------------------------------------------------
const input: Ref<string | undefined> = ref(props.data?.value || props.value)
const inputError: Ref<string | undefined> = ref(props.error)
const inputItem: Ref<HTMLInputElement | undefined> = ref()
const result: Ref<string | undefined> = ref()
const focus = ref(false)
const isEdit = ref(props.edit || props.base?.edit)

//------------------------------------------------------------------------------------------------------------
// ライフサイクル
//------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------
//watch
//------------------------------------------------------------------------------------------------------------
watch(
  () => props.value,
  (value) => {
    input.value = value
  }
)

watch(
  () => props.error,
  (value) => {
    inputError.value = value
  }
)

watch(
  () => props.data,
  (value) => {
    input.value = value?.value
    if (props.data) {
      if (value?.onCheck === 'check') {
        validation()
        props.data.onCheck = ''
      } else if (value?.onCheck === 'clear') {
        props.data.onCheck = ''
        props.data.error = ''
        inputError.value = ''
      }
      if (value?.error) {
        inputError.value = value?.error
      } else {
        inputError.value = ''
      }
    }
  },
  {
    deep: true,
  }
)

watch(
  () => props.edit,
  (value) => {
    if (value) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

watch(
  () => props.base,
  (value) => {
    if (value?.edit) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

//------------------------------------------------------------------------------------------------------------
// エミット
//------------------------------------------------------------------------------------------------------------
const emits = defineEmits<{
  (e: 'update:value', value: string): void
  (e: 'update:error', value: string): void
}>()

function onChange(e: Event) {
  const target = e.target as HTMLInputElement
  if (target) {
    input.value = target.value
    if (props.data) {
      props.data.value = target.value
    }
    validation()
    emits('update:value', target.value)
    emits('update:error', inputError.value || '')
  }
}

//------------------------------------------------------------------------------------------------------------
// メソッド
//------------------------------------------------------------------------------------------------------------
function onFocus() {
  focus.value = true
}
function onBlur() {
  focus.value = false
}

//------------------------------------------------------------------------------------------------------------
// バリデーション
//------------------------------------------------------------------------------------------------------------

function validation() {
  if (props.data) props.data.isCheck = true
  const rule: RULE[] = props.rule || props.data?.rule || []
  const ruleParams: ruleParams = {
    format: props.data?.ruleParams?.format,
    info: props.data?.ruleParams?.info,
    min: props.min || props.data?.ruleParams?.min,
    max: props.max || props.data?.ruleParams?.max,
    region: props.data?.ruleParams?.region, //zip-codeや、電話番号の国コード
  }

  const res = useValidation(input.value || '', rule, result, ruleParams)
  if (res === true) {
    inputError.value = ''
    if (props.data) {
      props.data.error = ''
    }
    return true
  } else {
    inputError.value = res
    if (props.data) {
      props.data.error = res
    }
    return false
  }
}
</script>

<style scoped>
.Input {
  position: relative;
  display: block;
  padding-top: 8px !important;
  padding-bottom: 8px !important;
  min-height: 72px;
  max-height: 300px;
  overflow-y: scroll;
}

.Preview {
  border: 1px solid rgba(var(--r-color-line), 0.5);
  color: rgba(var(--r-color-color), 1);
  background-color: rgba(var(--r-color-form), 0) !important;
}

.UpperMask {
  position: absolute;
  left: 4px;
  top: 0px;
  width: calc(100% - 22px);
  height: 11px;
  background-color: rgb(var(--r-color-form));
  border-top: 1px solid #999 !important;
}
.UpperMask.offLine {
  border-top: 1px solid rgba(var(--r-color-line), 0.5) !important;
  background-color: rgba(var(--r-color-background), 1) !important;
}

.LowerMask {
  position: absolute;
  left: 4px;
  bottom: 0px;
  width: calc(100% - 22px);
  height: 11px;
  background-color: rgb(var(--r-color-form));
  border-bottom: 1px solid #999 !important;
}
.LowerMask.offLine {
  border-bottom: 1px solid rgba(var(--r-color-line), 0.5) !important;
  background-color: rgba(var(--r-color-background), 1) !important;
}

.Resize {
  position: absolute;
  right: 2px;
  bottom: 2px;
  pointer-events: none;
  color: rgba(var(--r-color-color), 0.5) !important;
}
.Resize.offLine {
  color: rgba(var(--r-color-line), 1) !important;
}

.Input:focus ~ .UpperMask {
  border-top: 1px solid rgb(var(--r-color-formline)) !important;
}

.Input:focus ~ .LowerMask {
  border-bottom: 1px solid rgb(var(--r-color-formline)) !important;
}

.InputError ~ .UpperMask {
  border-top: 1px solid rgb(var(--r-color-error)) !important;
}

.InputError ~ .LowerMask {
  border-bottom: 1px solid rgb(var(--r-color-error)) !important;
}

.InputError:focus ~ .UpperMask {
  border-top: 1px solid rgb(var(--r-color-error)) !important;
}

.InputError:focus ~ .LowerMask {
  border-bottom: 1px solid rgb(var(--r-color-error)) !important;
}
</style>
