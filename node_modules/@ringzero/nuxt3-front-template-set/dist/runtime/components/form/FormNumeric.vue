<template>
  <FormBase
    class="FormNumeric"
    :base="base"
    :label="label"
    :rule="rule || data?.rule"
    :mode="mode"
    :edit="isEdit"
    :width="width || base?.width"
    :col-width="colWidth"
    :label-width="labelWidth"
    :hint="hint"
    :hintchip="hintchip"
    :error="inputError"
    :result="result"
    :focus="focus"
    :small="small"
    :medium="medium"
  >
    <div class="FormInputContainer">
      <div v-if="prefix" class="Prefix">{{ prefix }}</div>
      <div
        class="FormInputContent"
        :style="{
          width: width ? width + 'px' : base?.width ? base.width + 'px' : '100%',
          height: base?.small || small ? '20px' : '36px',
        }"
      >
        <template v-if="isEdit">
          <input
            :id="props.data?.name"
            :name="props.data?.name"
            class="Input"
            :class="{ InputError: inputError, Small: base?.small || small }"
            ref="inputItem"
            type="text"
            :value="input"
            @input="onChange"
            autocomplete="off"
            :placeholder="placeholder"
          />
          <ButtonInnerForm
            :icon="FORM_ICONS.RIGHT"
            :size="base?.small || small ? 20 : 34"
            :width="base?.small || small ? 12 : 18"
            :color="iconColor"
            :iconStyle="{ marginRight: '4px' }"
            :style="{
              right: base?.small || small ? '0px' : '0px',
              height: base?.small || small ? '20px' : '34px',
            }"
            @click="onIncrease"
            @mousedown="onSliderStart"
          />
          <ButtonInnerForm
            :icon="FORM_ICONS.LEFT"
            :iconStyle="{ marginLeft: '4px' }"
            :size="base?.small || small ? 20 : 34"
            :width="base?.small || small ? 12 : 18"
            :style="{ right: base?.small || small ? '12px' : '18px', height: base?.small || small ? '20px' : '34px' }"
            :color="iconColor"
            @click="onReduce"
            @mousedown="onSliderStart"
          />
        </template>
        <input v-else type="text" class="Preview" :value="input" disabled />
      </div>
      <div v-if="suffix" class="Suffix">{{ suffix }}</div>
    </div>
  </FormBase>
</template>

<script setup lang="ts">
/**===================================================================================================================
   * 数値入力
   ===================================================================================================================**/
import { FORM_MODE, type formProps, type formItem } from '../../components/common'
import { RULE, useValidation } from '../../composables/validation'
import { ref, watch, type Ref } from 'vue'
import { useMask } from '../../composables/utility'
import { FORM_ICONS } from '../../composables/constants'
//------------------------------------------------------------------------------------------------------------
// 引数
//------------------------------------------------------------------------------------------------------------
interface Props extends formProps {
  rule?: any
  value?: string
  countMin?: number
  countMax?: number
  step?: number
  iconColor?: string
}

const props = withDefaults(defineProps<Props>(), { step: 1, countMin: 0, countMax: 100 })
//------------------------------------------------------------------------------------------------------------
// 定数・変数（state）
//------------------------------------------------------------------------------------------------------------
const input: Ref<string | undefined> = ref(props.data?.value || props.value)
const inputError: Ref<string | undefined> = ref(props.error)
const inputItem: Ref<HTMLInputElement | undefined> = ref()
const result: Ref<string | undefined> = ref()
const focus = ref(false)
const isEdit = ref(props.edit || props.base?.edit)
//------------------------------------------------------------------------------------------------------------
// ライフサイクル
//------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------
//watch
//------------------------------------------------------------------------------------------------------------
watch(
  () => props.value,
  (value) => {
    if (value !== null && value !== undefined) {
      if (+value < props.countMin) {
        input.value = `${props.countMin}`
      } else if (+value > props.countMax) {
        input.value = `${props.countMax}`
      } else {
        input.value = value
      }
    } else {
      input.value = `${props.countMin}`
    }
  }
)

watch(
  () => props.error,
  (value) => {
    inputError.value = value
  }
)

watch(
  () => props.data,
  (value) => {
    if (value && value.value !== null && value.value !== undefined) {
      if (+value.value < props.countMin) {
        input.value = `${props.countMin}`
      } else if (+value.value > props.countMax) {
        input.value = `${props.countMax}`
      } else {
        input.value = value.value
      }
    } else {
      input.value = `${props.countMin}`
    }

    if (props.data) {
      if (value?.onCheck === 'check') {
        validation()
        props.data.onCheck = ''
      } else if (value?.onCheck === 'clear') {
        props.data.onCheck = ''
        props.data.error = ''
        inputError.value = ''
      }
    }
    if (value?.error) {
      inputError.value = value?.error
    }
  },
  {
    deep: true,
  }
)

watch(
  () => props.edit,
  (value) => {
    if (value) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

watch(
  () => props.base,
  (value) => {
    if (value?.edit) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

//------------------------------------------------------------------------------------------------------------
// エミット
//------------------------------------------------------------------------------------------------------------
const emits = defineEmits<{
  (e: 'update:value', value: string): void
  (e: 'update:error', value: string): void
}>()

function emit() {
  if (props.data) {
    props.data.value = input.value
  }
  if (input.value) {
    emits('update:value', input.value)
    emits('update:error', inputError.value || '')
  }
}

//------------------------------------------------------------------------------------------------------------
// メソッド
//------------------------------------------------------------------------------------------------------------
function onChange(e: Event) {
  const target = e.target as HTMLInputElement
  if (target) {
    input.value = target.value
    if (validation()) {
      checkRange(Number(input.value))
    }
    emit()
  }
}
const mask = useMask()
const sliderOn = ref(false)
const sliderX = ref(0)
const sliderNum = ref(0)
function onSliderStart(e: MouseEvent) {
  sliderX.value = e.clientX
  sliderOn.value = false
  sliderNum.value = Number(input.value)
  window.addEventListener('mousemove', onSliderMove, { passive: true })
  window.addEventListener('mouseup', onSliderEnd)
}

function onSliderMove(e: MouseEvent) {
  mask.on('ew-resize')
  sliderOn.value = true
  const delta = Math.round((e.clientX - sliderX.value) / 2)
  if (!isNaN(sliderNum.value)) {
    checkRange(sliderNum.value + delta * props.step)
  }
}

function onSliderEnd() {
  sliderOn.value = false
  window.removeEventListener('mousemove', onSliderMove)
  window.removeEventListener('mouseup', onSliderEnd)
  validation()
  emit()
  mask.off()
}

function onIncrease() {
  if (sliderOn.value) return
  if (input.value != null && input.value != undefined && !isNaN(Number(input.value))) {
    checkRange(Number(input.value) + props.step)
  }

  validation()
  emit()
}

function onReduce() {
  if (sliderOn.value) return
  if (input.value != null && input.value != undefined && !isNaN(Number(input.value))) {
    checkRange(Number(input.value) - props.step)
  }
  validation()
  emit()
}

function checkRange(value: number) {
  let result = Math.round(value * 1000) / 1000

  if (props.countMin !== undefined && props.countMin > value) {
    result = props.countMin
  }
  if (props.countMax !== undefined && props.countMax < value) {
    result = props.countMax
  }
  input.value = result.toString()
}

//------------------------------------------------------------------------------------------------------------
// バリデーション
//------------------------------------------------------------------------------------------------------------

function validation() {
  if (props.data) props.data.isCheck = true

  //RULEの確認
  const rule: RULE[] = props.rule || props.data?.rule || []
  if (!rule.includes(RULE.numeric)) {
    rule.push(RULE.numeric)
  }

  const res = useValidation(input.value || '', rule, result, props.data?.ruleParams)
  if (res === true) {
    inputError.value = ''
    if (props.data) props.data.error = ''
    return true
  } else {
    inputError.value = res
    if (props.data) props.data.error = res
    return false
  }
}
</script>

<style scoped>
.Input {
  position: relative;
  padding-right: 36px !important;
}

.Preview {
  position: relative;
  padding-right: 36px !important;
}

.decrease {
  right: 24px;
}

.increase {
  right: 0px;
}
</style>
