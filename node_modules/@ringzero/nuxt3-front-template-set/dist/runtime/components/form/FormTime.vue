<template>
  <FormBase
    class="FormTime"
    :base="base"
    :label="label"
    :rule="rule || data?.rule"
    :mode="mode"
    :edit="isEdit"
    :width="width || base?.width"
    :col-width="colWidth"
    :label-width="labelWidth"
    :hint="hint"
    :hintchip="hintchip"
    :error="inputError"
    :result="result"
    :focus="focus"
    :small="small"
    :medium="medium"
  >
    <div class="FormInputContainer" ref="InputArea">
      <div v-if="prefix" class="Prefix">{{ prefix }}</div>
      <div
        class="FormInputContent"
        :style="{
          width: width ? width + 'px' : base?.width ? base.width + 'px' : '100%',
        }"
      >
        <template v-if="isEdit">
          <input
            :id="props.data?.name"
            :name="props.data?.name"
            class="Input"
            :class="{ InputError: inputError }"
            ref="inputItem"
            type="text"
            :value="input"
            :placeholder="placeholder"
            @input="onChange"
            @focus="onFocus"
            @blur="onBlur"
          />
        </template>
        <input v-else type="text" class="Preview" :value="input" disabled />
        <ButtonInnerForm
          v-if="isEdit"
          class="Icon"
          :icon="FORM_ICONS.TIME"
          :size="16"
          :width="30"
          :align="ALIGN.RIGHT"
          @click="onShowSelect"
        />
      </div>
      <div v-if="suffix" class="Suffix">{{ suffix }}</div>
    </div>
    <PartsFloatCard :inputArea="InputArea ? InputArea : null" :switcher="modalSwitch">
      <div :class="{ grabbing: isDragging }">
        <div class="PickTime">
          <input
            class="TimePart"
            :class="{ SelectedTime: activeFrame === 0, ErrorBorder: hourError }"
            v-model="currentHour"
            type="text"
            pattern="[0-9]{2}"
            maxlength="2"
            @click.stop="onClickTime(0)"
            @input="inputForm($event, 0)"
            @mousedown="onHourMouseDown"
          />
          <span>:</span>
          <input
            class="TimePart"
            :class="{ SelectedTime: activeFrame === 1, ErrorBorder: minuteError }"
            v-model="currentMinute"
            type="text"
            pattern="[0-9]{2}"
            maxlength="2"
            @click.stop="onClickTime(1)"
            @input="inputForm($event, 1)"
            @mousedown="onMinuteMouseDown"
          />
          <span>:</span>
          <input
            class="TimePart"
            :class="{ SelectedTime: activeFrame === 2, ErrorBorder: secondError }"
            v-model="currentSecond"
            type="text"
            pattern="[0-9]{2}"
            maxlength="2"
            @click.stop="onClickTime(2)"
            @input="inputForm($event, 2)"
            @mousedown="onSecondMouseDown"
          />
        </div>
        <div class="TimeArea">
          <div class="Buttons" @click="formatDate">
            <button
              v-if="activeFrame !== 0 && !verticalSwitch.opened"
              class="Button mr-2"
              @click.stop="changeContent('down')"
            >
              &lt;
            </button>
            <button v-if="activeFrame === 0 && !verticalSwitch.opened" class="HiddenButton mr-2"></button>
          </div>
          <div class="VerticalMenu" v-if="verticalSwitch.opened && displayVerticalMenu" :style="themeStyles">
            <div v-if="activeFrame === 0">
              <div
                v-for="h in hourRange"
                :key="h"
                class="Time"
                :class="['HoverVertivalMenu', { selected: h - 1 === selectVerticalHour }]"
                ref="divRef"
                @click.stop="verticalSetHour(h - 1)"
              >
                {{ (h - 1).toString().padStart(2, '0') }}
              </div>
            </div>
            <div v-if="activeFrame === 1">
              <div
                v-for="m in minuteRange"
                :key="m"
                class="Time"
                :class="['HoverVertivalMenu', { selected: m - 1 === selectVerticalMinute }]"
                ref="divRef"
                @click.stop="verticalSetMinute(m - 1)"
              >
                {{ (m - 1).toString().padStart(2, '0') }}
              </div>
            </div>
            <div v-if="activeFrame === 2">
              <div
                v-for="s in secondRange"
                :key="s"
                class="Time"
                :class="['HoverVertivalMenu', { selected: s - 1 === selectVerticalSecond }]"
                ref="divRef"
                @click.stop="verticalSetSecond(s - 1)"
              >
                {{ (s - 1).toString().padStart(2, '0') }}
              </div>
            </div>
          </div>
          <div class="Clock" v-else>
            <PartsClock
              :selectType="CLOCK_TYPE.DIAL"
              :hour="currentHour"
              :minute="currentMinute"
              :second="currentSecond"
              :activeFrame="activeFrame"
              :reset="resetClockStatus"
              :action="false"
              @update:time="selectTime"
              @update:value="changeFrame"
              @update:input-state="updateEditState"
              @update:reset="resetClock"
            />
          </div>
          <div class="Buttons" @click="formatDate">
            <button
              v-if="activeFrame !== 2 && !verticalSwitch.opened"
              class="Button ml-2"
              @click.stop="changeContent('up')"
            >
              >
            </button>
            <button v-if="activeFrame === 2 && !verticalSwitch.opened" class="HiddenButton ml-2"></button>
          </div>
        </div>
        <div class="ButtonArea Set1">
          <ButtonSimple
            v-for="(button, i) in buttons"
            class="DialogButton"
            color="#fff"
            :key="i"
            :width="button.width"
            :text="button.label"
            :small="button.small"
            :backcolor="button.getBackgroundColor ? button.getBackgroundColor() : button.type"
            @click="onClick(i)"
          />
        </div>
      </div>
    </PartsFloatCard>
  </FormBase>
</template>

<script setup lang="ts">
/**===================================================================================================================
   *
   ===================================================================================================================**/
import { CLOCK_TYPE, type formProps } from '../../components/common'
import { RULE, useValidation } from '../../composables/validation'
import dayjs from 'dayjs'
import { THEME_COLOR, FORM_ICONS, ALIGN } from '../../composables/constants'
import { useColor } from '../../composables/colors'
import { ref, watch, type Ref, computed, nextTick } from 'vue'
import type { ModalSwitch } from '../../types'
//------------------------------------------------------------------------------------------------------------
// 引数
//------------------------------------------------------------------------------------------------------------
interface Props extends formProps {
  rule?: any
  value?: string
}

const props = withDefaults(defineProps<Props>(), {})
//------------------------------------------------------------------------------------------------------------
// 定数・変数（state）
//------------------------------------------------------------------------------------------------------------
const input: Ref<string | undefined> = ref(props.data?.value || props.value)
const inputError: Ref<string | undefined> = ref(props.error)
const inputItem: Ref<HTMLInputElement | undefined> = ref()
const result: Ref<string | undefined> = ref()
const focus = ref(false)
const isEdit = ref(props.edit || props.base?.edit)

//モーダル系
const InputArea: Ref<HTMLDivElement | null> = ref(null)
const modalSwitch: Ref<ModalSwitch> = ref({ opened: false })
const verticalSwitch: Ref<ModalSwitch> = ref({ opened: false })
const buttons = ref([
  { label: 'キャンセル', width: 80, small: true, type: THEME_COLOR.secondary },
  { label: 'リセット', width: 80, small: true, type: THEME_COLOR.error },
  {
    label: 'OK',
    width: 80,
    small: false,
    type: THEME_COLOR.primary,
    getBackgroundColor: () => (checkField.value ? THEME_COLOR.guide : THEME_COLOR.primary),
  },
])

// 時計変数
// 時計のフレームの位置
const activeFrame: Ref<number> = ref(0)
// インプットをクリックしたときのメニューの変数
const selectVerticalHour = ref(dayjs().hour())
const selectVerticalMinute = ref(dayjs().minute())
const selectVerticalSecond = ref(dayjs().second())
// インプットに表示する変数
const hour = ref(formatTime(dayjs().hour().toString()))
const minute = ref(formatTime(dayjs().minute().toString()))
const second = ref(formatTime(dayjs().second().toString()))
const currentHour = ref(formatTime(dayjs().hour().toString()))
const currentMinute = ref(formatTime(dayjs().minute().toString()))
const currentSecond = ref(formatTime(dayjs().second().toString()))
const time = ref(formatDateStr('1970-01-01', hour.value, minute.value, second.value))
const currentTime = ref(formatDateStr('1970-01-01', currentHour.value, currentMinute.value, currentSecond.value))
// 時間のレンジ
const hourRange = 23
const minuteRange = 59
const secondRange = 59

// 時間をドラッグして数値を変化させる値
const lastX = ref()
const accumulatedXDiff = ref(0)
// ドラッグ中カーソルの表示を変えるフラグ
const isDragging = ref(false)
// インプットをクリックしたときの位置指定に使用する変数
const divRef: Ref<HTMLDivElement[] | undefined> = ref()
const selectedElement: Ref<HTMLDivElement | undefined> = ref()
// インプットが編集中であるか判定するフラグ
const isEditingInput = ref(false)
// インプットをクリックしてメニューを表示するかのフラグ
const displayVerticalMenu = ref(false)
// 時計リセット
const resetClockStatus = ref(false)
//------------------------------------------------------------------------------------------------------------
//computed
//------------------------------------------------------------------------------------------------------------
// 使用するカラーを動的に変更
const themeStyles = computed(() => {
  return {
    '--back-color': useColor(THEME_COLOR.background),
    '--primary-color': useColor(THEME_COLOR.primary),
  }
})
// すべての変数が入力されているかをチェック
const checkField = computed(() => hourError.value || minuteError.value || secondError.value)
const hourError = computed(() => {
  return !/^\d{2}$/.test(currentHour.value) || !(Number(currentHour.value) >= 0 && Number(currentHour.value) < 24)
})

const minuteError = computed(() => {
  return !/^\d{2}$/.test(currentMinute.value) || !(Number(currentMinute.value) >= 0 && Number(currentMinute.value) < 60)
})

const secondError = computed(() => {
  return !/^\d{2}$/.test(currentSecond.value) || !(Number(currentSecond.value) >= 0 && Number(currentSecond.value) < 60)
})
//------------------------------------------------------------------------------------------------------------
//watch
//------------------------------------------------------------------------------------------------------------
watch(
  () => props.value,
  (value) => {
    // console.log('入ってきた値', value)
    input.value = value
    if (!value) {
      inputError.value = undefined
      value = dayjs('1970-01-01').format('HH:mm:ss')
    }
    const time = dayjs('1970-01-01' + ' ' + value).format('HH:mm:ss')
    const [datePart, timePart] = time.split(' ')

    if (timePart) {
      const parts = value.split(':')
      hour.value = parts[0]
      minute.value = parts[1]
      second.value = parts[2]
    }
  }
)

watch(
  () => props.error,
  (value) => {
    inputError.value = value
  }
)

watch(
  () => props.data,
  (value) => {
    input.value = value?.value
    if (props.data) {
      if (value?.onCheck === 'check') {
        validation()
        props.data.onCheck = ''
      } else if (value?.onCheck === 'clear') {
        props.data.onCheck = ''
        props.data.error = ''
        inputError.value = ''
      }
      if (value?.error) {
        inputError.value = value?.error
      } else {
        inputError.value = ''
      }
    }
  },
  {
    deep: true,
  }
)

watch(
  () => props.edit,
  (value) => {
    if (value) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

watch(
  () => props.base,
  (value) => {
    if (value?.edit) {
      isEdit.value = true
    } else {
      isEdit.value = false
    }
  }
)

// インプットをクリックしたときにdivに色を付けるための変数を動的に変更
watch(
  () => [currentHour.value, currentMinute.value, currentSecond.value],
  ([hourValue, minuteValue, secondValue]) => {
    selectVerticalHour.value = parseInt(hourValue)
    selectVerticalMinute.value = parseInt(minuteValue)
    selectVerticalSecond.value = parseInt(secondValue)
  }
)

watch(currentHour, (value) => {
  if (!/^\d+(\.\d+)?$/.test(value)) {
    currentHour.value = ''
  }
})

watch(currentMinute, (value) => {
  if (!/^\d+(\.\d+)?$/.test(value)) {
    currentMinute.value = ''
  }
})

watch(currentSecond, (value) => {
  if (!/^\d+(\.\d+)?$/.test(value)) {
    currentSecond.value = ''
  }
})
//------------------------------------------------------------------------------------------------------------
// エミット
//------------------------------------------------------------------------------------------------------------
const emits = defineEmits<{
  (e: 'update:value', value: string): void
  (e: 'update:error', value: string): void
}>()

function onChange(e: Event) {
  const target = e.target as HTMLInputElement
  if (target) {
    input.value = target.value
    if (props.data) {
      props.data.value = target.value
    }
    validation()
    emits('update:value', target.value)
    emits('update:error', inputError.value || '')
  }
}

// 時計で選択された値をエミットで変数に格納
function selectTime(hour: number, minute: number, second: number) {
  if (!isEditingInput.value) {
    if (activeFrame.value === 0) {
      currentHour.value = hour.toString().padStart(2, '0')
    } else if (activeFrame.value === 1) {
      currentMinute.value = minute.toString().padStart(2, '0')
    } else if (activeFrame.value === 2) {
      currentSecond.value = second.toString().padStart(2, '0')
    }
  } else {
    if (activeFrame.value === 0) {
      currentHour.value = hour.toString()
    } else if (activeFrame.value === 1) {
      currentMinute.value = minute.toString()
    } else if (activeFrame.value === 2) {
      currentSecond.value = second.toString()
    }
  }

  currentTime.value = formatDateStr('1970-01-01', currentHour.value, currentMinute.value, currentSecond.value)
}

// フレームの位置をエミットで変数に格納
function changeFrame(frameNum: number) {
  activeFrame.value = frameNum
}

// ボタンをクリックしたときの動作（0：キャンセル、1：リセット、2：OK）
function onClick(num: number) {
  if (num === 2) {
    if (hourError.value || minuteError.value || secondError.value) return
    hour.value = currentHour.value
    minute.value = currentMinute.value
    second.value = currentSecond.value
    time.value = formatDateStr('1970-01-01', hour.value, minute.value, second.value)
    // console.log('出ていく値', time.value)
    emits('update:value', time.value)
    input.value = time.value
    if (props.data) {
      props.data.value = time.value
    }
    validation()
    emits('update:value', time.value)
    emits('update:error', inputError.value || '')
    verticalSwitch.value.opened = false
    modalSwitch.value.opened = false
    inputError.value = undefined
  } else if (num === 1) {
    resetClockStatus.value = true
  } else if (num === 0) {
    verticalSwitch.value.opened = false
    modalSwitch.value.opened = false
  }
}

function updateEditState(value: boolean) {
  isEditingInput.value = value
}
//------------------------------------------------------------------------------------------------------------
// メソッド
//------------------------------------------------------------------------------------------------------------
function onFocus() {
  focus.value = true
}
function onBlur() {
  focus.value = false
}

// インプットをクリックして表示されるメニューの時を設定
function verticalSetHour(hour: number) {
  const hourStr = hour.toString().padStart(2, '0')
  const minuteStr = currentMinute.value.padStart(2, '0')
  const secondStr = currentSecond.value.padStart(2, '0')
  selectVerticalHour.value = hour
  currentTime.value = formatDateStr('1970-01-01', hourStr, minuteStr, secondStr)
  const fullTime = `1970-01-01 ${currentTime.value}`
  currentHour.value = dayjs(fullTime).hour().toString().padStart(2, '0')
}

// インプットをクリックして表示されるメニューの分を設定
function verticalSetMinute(minute: number) {
  const hourStr = currentMinute.value.toString().padStart(2, '0')
  const minuteStr = minute.toString().padStart(2, '0')
  const secondStr = currentSecond.value.padStart(2, '0')
  selectVerticalMinute.value = minute
  currentTime.value = formatDateStr('1970-01-01', hourStr, minuteStr, secondStr)
  const fullTime = `1970-01-01 ${currentTime.value}`
  currentMinute.value = dayjs(fullTime).minute().toString().padStart(2, '0')
}

// インプットをクリックして表示されるメニューの秒を設定
function verticalSetSecond(second: number) {
  const hourStr = currentHour.value.toString().padStart(2, '0')
  const minuteStr = currentMinute.value.padStart(2, '0')
  const secondStr = second.toString().padStart(2, '0')
  selectVerticalSecond.value = second
  currentTime.value = formatDateStr('1970-01-01', hourStr, minuteStr, secondStr)
  const fullTime = `1970-01-01 ${currentTime.value}`
  currentSecond.value = dayjs(fullTime).second().toString().padStart(2, '0')
}

// インプットをクリックして表示するメニュー
function onClickTime(frameNum: number) {
  activeFrame.value = frameNum
  // メニューは、現時点で必要ないためコメントオフ
  // verticalSwitch.value.opened = true

  nextTick().then(() => {
    if (!/^\d+$/.test(currentHour.value)) {
      currentHour.value = ''
    }
    if (!/^\d+$/.test(currentMinute.value)) {
      currentMinute.value = ''
    }
    if (!/^\d+$/.test(currentSecond.value)) {
      currentSecond.value = ''
    }

    setTimeout(() => {
      const elements = divRef.value
      if (!elements) return
      selectedElement.value = Array.from(elements).find((el) => el.classList.contains('selected'))
      if (!selectedElement.value) return
      adjustScrollPosition(selectedElement.value)
    }, 5)
  })
  isEditingInput.value = true
}

// 1桁の数値の前に０を足す
function formatTime(value: string) {
  return value.toString().padStart(2, '0')
}

// 日時のフォーマットを合わせる
function formatDateStr(baseDate: string, h: string, m: string, s: string) {
  return dayjs(`${baseDate} ${h}:${m}:${s}`).format('HH:mm:ss')
}

// FlortCardが開かれるときに数値を最新の数値を格納する
function onShowSelect() {
  activeFrame.value = 0
  const selectedTime = input.value || dayjs().format('HH:mm:ss')
  const [hourPart, minutePart, secondPart] = selectedTime.split(':')
  if (hourPart) currentHour.value = hourPart
  if (minutePart) currentMinute.value = minutePart
  if (secondPart) currentSecond.value = secondPart

  if (hourPart === '00' && minutePart === '00' && secondPart === '00') {
    currentHour.value = formatTime(dayjs().hour().toString())
    currentMinute.value = formatTime(dayjs().minute().toString())
    currentSecond.value = formatTime(dayjs().second().toString())
  }
  modalSwitch.value.opened = true
}

// もともとクロックでactiveFrame=0をしようしているため、それに合わせてcalendarは-1から始めている
function changeContent(value: string) {
  if (value === 'down') {
    if (activeFrame.value === 0) return
    activeFrame.value -= 1
  } else if (value === 'up') {
    if (activeFrame.value === 2) return
    activeFrame.value += 1
  }
}

// ドラッグしたときに発火
function handleMouseDown(event: MouseEvent, mouseMoveHandler: any, mouseUpHandler: any, frameNum: number) {
  isDragging.value = true
  activeFrame.value = frameNum
  lastX.value = event.clientX
  window.addEventListener('mousemove', mouseMoveHandler)
  window.addEventListener('mouseup', mouseUpHandler)
}

// ドラッグして動いたときに発火
function handleMouseMove(event: MouseEvent, currentValue: string, min: number, max: number, type: string) {
  isEditingInput.value = false
  let variation = 10
  if (type === 'minute' || type === 'second') {
    variation = 1
  }

  const diffX = event.clientX - lastX.value
  accumulatedXDiff.value += diffX

  let int = parseInt(currentValue, 10)

  if (Math.abs(accumulatedXDiff.value) >= variation) {
    if (accumulatedXDiff.value > 0) {
      int = int === max ? min : int + 1
    } else if (accumulatedXDiff.value < 0) {
      int = int === min ? max : int - 1
    }
    accumulatedXDiff.value = 0
  }

  currentValue = int < 10 ? '0' + int : int.toString()
  if (type === 'hour') {
    currentHour.value = int < 10 ? '0' + int.toString() : int.toString()
  } else if (type === 'minute') {
    currentMinute.value = int < 10 ? '0' + int.toString() : int.toString()
  } else if (type === 'second') {
    currentSecond.value = int < 10 ? '0' + int.toString() : int.toString()
  }

  lastX.value = event.clientX
}

// ドラッグが終わったときに発火
function handleMouseUp(mouseMoveHandler: any) {
  isDragging.value = false
  window.removeEventListener('mousemove', mouseMoveHandler)
}

function onHourMouseDown(event: MouseEvent) {
  handleMouseDown(event, onHourMouseMove, onHourMouseUp, 0)
}

function onHourMouseMove(event: MouseEvent) {
  handleMouseMove(event, currentHour.value, 0, 23, 'hour')
}

function onHourMouseUp() {
  handleMouseUp(onHourMouseMove)
}

function onMinuteMouseDown(event: MouseEvent) {
  handleMouseDown(event, onMinuteMouseMove, onMinuteMouseUp, 1)
}

function onMinuteMouseUp() {
  handleMouseUp(onMinuteMouseMove)
}

function onMinuteMouseMove(event: MouseEvent) {
  handleMouseMove(event, currentMinute.value, 0, 59, 'minute')
}

function onSecondMouseDown(event: MouseEvent) {
  handleMouseDown(event, onSecondMouseMove, onSecondMouseUp, 2)
}

function onSecondMouseMove(event: MouseEvent) {
  handleMouseMove(event, currentSecond.value, 0, 59, 'second')
}

function onSecondMouseUp() {
  handleMouseUp(onSecondMouseMove)
}

function adjustScrollPosition(element: HTMLDivElement) {
  const rect = element.getBoundingClientRect()
  const container = document.querySelector('.VerticalMenu')
  if (!container) return
  const containerRect = container.getBoundingClientRect()
  const containerCenter = containerRect.top + containerRect.height / 2
  const offset = rect.top + rect.height / 2 - containerCenter
  container.scrollTop += offset
}

// インプットをクリックしたして表示したメニューの範囲外をクリックしたときに、空や半端に入力された数字に一番近しい数字を当てる
function formatDate() {
  verticalSwitch.value.opened = false
  isEditingInput.value = false
  // 年の入力値をチェックし、範囲外であれば修正する
  const hourValue = parseInt(currentHour.value, 10)
  const minuteValue = parseInt(currentMinute.value, 10)
  const secondValue = parseInt(currentSecond.value, 10)

  if (hourValue < 0) {
    currentHour.value = '00'
  } else if (hourValue > 23) {
    currentHour.value = '23'
  } else if (Number.isNaN(hourValue)) {
    currentHour.value = '00'
  }

  if (minuteValue < 0) {
    currentMinute.value = '00'
  } else if (minuteValue > 59) {
    currentMinute.value = '59'
  } else if (Number.isNaN(minuteValue)) {
    currentMinute.value = '00'
  }

  if (secondValue < 0) {
    currentSecond.value = '00'
  } else if (secondValue > 59) {
    currentSecond.value = '59'
  } else if (Number.isNaN(secondValue)) {
    currentSecond.value = '00'
  }
  currentTime.value = formatDateStr('1970-01-01', currentHour.value, currentMinute.value, currentSecond.value)
}

// インプットに入力された数字を代入
function inputForm(event: any, activeFrame: number) {
  const time = event.target.value
  isEditingInput.value = true

  if (activeFrame === 0) {
    if (event.inputType === 'deleteContentBackward') {
      isEditingInput.value = true
    } else if (event.inputType === 'insertText') {
      if (time.length === 2) {
        isEditingInput.value = true
      } else {
        isEditingInput.value = false
      }
    }
    currentHour.value = time
  } else if (activeFrame === 1) {
    if (event.inputType === 'deleteContentBackward') {
      isEditingInput.value = true
    } else if (event.inputType === 'insertText') {
      if (time.length === 2) {
        isEditingInput.value = true
      } else {
        isEditingInput.value = false
      }
    }
    currentMinute.value = time
  } else if (activeFrame === 2) {
    if (event.inputType === 'deleteContentBackward') {
      isEditingInput.value = true
    } else if (event.inputType === 'insertText') {
      if (time.length === 2) {
        isEditingInput.value = true
      } else {
        isEditingInput.value = false
      }
    }
    currentSecond.value = time
  }

  currentTime.value = formatDateStr('1970-01-01', currentHour.value, currentMinute.value, currentSecond.value)
}

// リセット系
function resetClock(value: boolean) {
  // console.log(value)
  currentHour.value = '00'
  currentMinute.value = '00'
  currentSecond.value = '00'
  currentTime.value = dayjs(
    '1970-01-01' + ' ' + `${currentHour.value}:${currentMinute.value}:${currentSecond.value}`
  ).format('HH:mm:ss')
  hour.value = '00'
  minute.value = '00'
  second.value = '00'
  time.value = dayjs('1970-01-01' + ' ' + `${hour.value}:${minute.value}:${second.value}`).format('HH:mm:ss')
  selectVerticalHour.value = 0
  selectVerticalMinute.value = 0
  selectVerticalSecond.value = 0
  isEditingInput.value = false
  resetClockStatus.value = value
}
//------------------------------------------------------------------------------------------------------------
// バリデーション
//------------------------------------------------------------------------------------------------------------

function validation() {
  if (props.data) props.data.isCheck = true

  //RULEの確認
  const rule: RULE[] = props.rule || props.data?.rule || []
  if (!rule.includes(RULE.time)) {
    rule.push(RULE.time)
  }

  const res = useValidation(input.value || '', rule, result, props.data?.ruleParams)
  if (res === true) {
    inputError.value = ''
    if (props.data) props.data.error = ''
    return true
  } else {
    inputError.value = res
    if (props.data) props.data.error = res
    return false
  }
}
</script>

<style scoped>
.Input {
  position: relative;
}

.Preview {
  position: relative;
}

.Icon {
  position: absolute;
}

.PickTime {
  margin-top: 15px;
  display: flex;
  justify-content: center;
  font-size: 14px;
  height: 22px;
}

span {
  height: 22px;
  line-height: 22px;
}

.TimePart {
  width: 32px;
  text-align: center;
  line-height: 22px;
  border: 1px solid #000;
  border-radius: 5px;
}

.SelectedTime {
  width: 39px;
  font-size: 15px;
  font-weight: bold;
  color: #000;
}

.Time {
  width: 200px;
  margin: 0 auto;
}

.PickTime > div,
.PickTime > span {
  line-height: 20px;
}

.ButtonArea {
  position: absolute;
  width: 100%;
  bottom: 14px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.ButtonArea .DialogButton:not(:last-child) {
  margin-right: 10px;
}

.grabbing * {
  cursor: ew-resize !important;
}

.VerticalMenu {
  width: 250px;
  height: 280px;
  text-align: center;
  margin: 10px auto 0 auto;
  overflow-y: scroll;
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.HoverVertivalMenu:hover {
  background-color: var(--back-color);
}

.HoverVertivalMenu.selected,
.HoverVertivalMenu:hover.selected {
  background-color: var(--primary-color);
}

.ErrorBorder {
  border: 2px solid red;
}

.TimeArea {
  display: flex;
  justify-content: center;
}

.Buttons {
  display: flex;
}

.Button,
.HiddenButton {
  margin: auto 0px;
  width: 25px;
  height: 25px;
  font-size: 15px;
  font-weight: bold;
  border-radius: 50%;
  color: rgb(61, 146, 174);
  box-shadow: 1px 1px 3px rgba(148, 148, 148, 0.24);
}

.HiddenButton {
  visibility: hidden;
}

Button:hover {
  opacity: 0.8;
}

Button:active {
  -webkit-transform: translate(0, 1px);
  -moz-transform: translate(0, 1px);
  transform: translate(0, 1px);
}

.Clock {
  margin-top: 15px;
}
</style>
