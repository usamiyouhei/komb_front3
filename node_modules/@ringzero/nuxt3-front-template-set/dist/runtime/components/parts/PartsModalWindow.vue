<template>
  <!-- モーダルウィンドウ -->
  <div
    class="ActiveRect"
    :class="{
      transitionAll: transitionAll,
      Modeless: isModeless,
    }"
    :style="{
      left: `${activeRect.left}px`,
      top: `${activeRect.top}px`,
      width: `${activeRect.width}px`,
      height: `${activeRect.height}px`,
      minHeight: fixedRect.canvasMinHeight,
      maxHeight: fixedRect.canvasMaxHeight,
      display: isOpen ? (isFixed ? 'flex' : 'block') : 'none',
      borderRadius: `${activeRect.radius}px`,
      justifyContent: isFixed ? fixedRect.justify : undefined,
      alignItems: isFixed ? fixedRect.align : undefined,
    }"
  >
    <div
      ref="modalWindow"
      class="ModalWindow"
      :class="{ Small: small }"
      :style="{
        position: isFixed || !isMoved ? 'relative' : 'absolute',
        left: isFixed ? fixedRect.offsetX : `${winSize.x}px`,
        top: isFixed ? fixedRect.offsetY : `${winSize.y}px`,
        width: isFixed && !resize ? fixedRect.width : `${winSize.width}px`,
        height: isFixed && !resize ? fixedRect.height : `${winSize.height}px`,
        minWidth: isFixed && !resize ? fixedRect.minWidth : undefined,
        maxWidth: isFixed && !resize ? fixedRect.maxWidth : undefined,
        minHeight: isFixed && !resize ? fixedRect.minHeight : undefined,
        maxHeight: isFixed && !resize ? fixedRect.maxHeight : undefined,
      }"
    >
      <div
        ref="modalWindow"
        class="Title"
        :class="{ Fixed: isFixed || !isMoved }"
        :style="{ backgroundColor: titleBack }"
        @mousedown="onMoveStart"
      >
        <slot name="title">
          <div class="TitleInner">{{ title }}</div>
        </slot>
      </div>
      <div v-if="scroll" class="Content">
        <div class="ContentScroll" :style="{ overflowX: 'hidden', overflowY: 'scroll' }">
          <div class="ContentInner">
            <slot>
              <table>
                <tr>
                  <th>name</th>
                  <td>{{ name }}</td>
                </tr>
                <tr>
                  <th>Level</th>
                  <td>{{ activeRectLevel }}</td>
                </tr>
                <tr>
                  <th>activeRect</th>
                  <td>{{ activeRect }}</td>
                </tr>
                <tr>
                  <th>winSize</th>
                  <td>{{ winSize }}</td>
                </tr>
                <tr>
                  <th>variableRect</th>
                  <td>{{ variableRect }}</td>
                </tr>
                <tr>
                  <th>fixedSize</th>
                  <td>{{ fixedSize }}</td>
                </tr>
                <tr>
                  <th>modeless</th>
                  <td>{{ isModeless }}</td>
                </tr>
                <tr>
                  <th>fixed</th>
                  <td>{{ isFixed }}</td>
                </tr>
                <tr>
                  <th>reset</th>
                  <td>{{ isReset }}</td>
                </tr>
              </table>
            </slot>
          </div>
        </div>
      </div>
      <div v-else class="Content">
        <slot />
      </div>
      <div class="HeaderSlot">
        <slot name="header" />
      </div>
      <ButtonIcon
        v-if="close"
        :icon="ICONS.CLOSE"
        class="CloseButton"
        :color="isFixed || !isMoved ? useColor(THEME_COLOR.color) : useColor(THEME_COLOR.reverse)"
        light
        @click="onClose"
      />
      <ButtonIcon
        v-if="resize"
        class="ExpanderButton"
        :icon="ICONS.RESIZE"
        :color="THEME_COLOR.color"
        @mousedown="onResizeStart"
      />
      <div v-if="((isFixed || !isMoved) && resize) || (!isFixed && isMoved)" class="RestoreWindow">
        <PartsTooltip
          :text="isFixed ? 'サイズの初期化' : 'サイズ・位置の初期化'"
          class=""
          :position="POSITION.TOP"
          :offsetX="isFixed ? -10 : 0"
          :arrowOffsetX="isFixed ? -10 : 0"
          :backcolor="!modeless ? THEME_COLOR.form : undefined"
          :color="!modeless ? THEME_COLOR.color : undefined"
        >
          <ButtonIcon
            icon="mdi-window-maximize"
            class="RestoreButton"
            :color="isFixed || !isMoved ? useColor(THEME_COLOR.color) : useColor(THEME_COLOR.reverse)"
            @mousedown="onResetSize"
          />
        </PartsTooltip>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
//今回printWidthは120にしてるので、この===の長さを目安にコードを整える
/**===================================================================================================================
   * モーダルウィンドウ
   * タイトルバーをドラックで移動できる
   ===================================================================================================================**/
import { useModalSetting, type ModalRect } from '../../composables/modalWindow'
import { FORM_ICONS, ICONS, THEME_COLOR, POSITION } from '../../composables/constants'
import { ref, watch, type Ref, onBeforeUnmount, onMounted } from 'vue'
import { useActiveRectNum } from '../../composables/utility'
import { useLocalMenuStatus, useMainNavigationStatus } from '../../composables/states'
import { useColor } from '../../composables/colors'
import type { FixedSize, VariableSize } from '../common'
import type { ModalSwitch } from '../../types'

//------------------------------------------------------------------------------------------------------------
// 引数
//------------------------------------------------------------------------------------------------------------
interface Props {
  name?: string //ウィンドウ位置保存の為の名前になる
  title?: any
  level?: number
  zindex?: number
  modeless?: boolean
  switcher: ModalSwitch
  titleBack?: string
  scroll?: boolean
  fixed?: boolean
  reset?: boolean
  moved?: boolean
  small?: boolean
  resize?: boolean
  variableSize?: VariableSize
  fixedSize?: FixedSize
  close?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  name: 'DefaultModalWindow',
  title: 'モーダルウィンドウ',
  zindex: 0,
  level: 0,
  buttonNum: 0,
  modeless: false,
  scroll: true,
  resize: true,
  moved: true,
  close: true,
  //他のObject形式の型だと現状ではTSエラーになってしまう。どちらにしても保存したデータからの復帰があるので、onBeforeMountで行う
})

//------------------------------------------------------------------------------------------------------------
// 定数・変数（state）
//------------------------------------------------------------------------------------------------------------
const modalWindow: Ref<HTMLElement | undefined> = ref()
const activeRect = ref(useActiveRectNum(props.level))
const transitionAll = ref(true)
const modalSetting = useModalSetting()
const isModeless = ref(props.modeless)
const isFixed = ref(props.fixed)
const isReset = ref(props.reset)
const isResize = ref(props.resize)
const isMoved = ref(props.moved)
const variableRect = ref({
  x: props.variableSize?.x || 100,
  y: props.variableSize?.y || 100,
  width: props.variableSize?.width || 400,
  minWidth: props.variableSize?.minWidth || 300,
  maxWidth: props.variableSize?.maxWidth || 600,
  height: props.variableSize?.height || 500,
  minHeight: props.variableSize?.minHeight || 700,
  maxHeight: props.variableSize?.maxHeight || 900,
  justify: props.variableSize?.justify || 'start',
  align: props.variableSize?.align || 'start',
})
const fixedRect = ref({
  justify: props.fixedSize?.justify || 'center',
  align: props.fixedSize?.align || 'center',
  offsetX: props.fixedSize?.offsetX || 0,
  offsetY: props.fixedSize?.offsetY || 0,
  width: props.fixedSize?.width || '400px',
  height: props.fixedSize?.height || '600px',
  minHeight: props.fixedSize?.minHeight || '10px',
  maxHeight: props.fixedSize?.maxHeight || '600px',
  minWidth: props.fixedSize?.minWidth || '300px',
  maxWidth: props.fixedSize?.maxWidth || '600px',

  canvasMinHeight: props.fixedSize?.canvasMinHeight || '600px',
  canvasMaxHeight: props.fixedSize?.canvasMaxHeight || undefined,
})

const winSize: Ref<ModalRect> = ref({
  name: props.name,
  x: variableRect.value.x,
  y: variableRect.value.y,
  width: variableRect.value.width,
  height: variableRect.value.height,
})

//------------------------------------------------------------------------------------------------------------
// ライフサイクル
//------------------------------------------------------------------------------------------------------------
onMounted(() => {
  // console.log('保存されたダイアログ', modalSetting.value[props.name])
  const saveData = modalSetting.value[props.name]
  if (saveData) {
    winSize.value = saveData
  } else {
    resetValue(true)
  }

  activeRectCheck()
  window.addEventListener('resize', onWindowResize, { passive: true })
})

onBeforeUnmount(() => {
  //window.removeEventListener('resize', onGetPosition)
  window.removeEventListener('mousemove', onMouseMove)
  window.removeEventListener('mouseup', onMouseUp)
  window.removeEventListener('mousemove', onResizeMove)
  window.removeEventListener('mouseup', onResizeUp)
  window.removeEventListener('resize', onWindowResize)
})

//------------------------------------------------------------------------------------------------------------
// watch
// propの変化をキャッチする場合は、watchを使う
//------------------------------------------------------------------------------------------------------------
watch(
  () => props.switcher,
  (value) => {
    transitionAll.value = true
    isOpen.value = value.opened
    sizeCheck()
  },
  {
    deep: true,
  }
)

watch(
  () => props.level,
  (value) => {
    transitionAll.value = true
    activeRectLevel.value = value
    activeRectCheck()
  }
)

const navi = useMainNavigationStatus()
const local = useLocalMenuStatus()
watch(
  () => navi.value.width,
  () => {
    transitionAll.value = true
    activeRectCheck()
  }
)

watch(
  () => local.value.width,
  () => {
    transitionAll.value = true
    activeRectCheck()
  }
)

watch(
  () => props.modeless,
  (value) => {
    isModeless.value = value
  }
)

watch(
  () => props.fixed,
  (value) => {
    isFixed.value = value
  }
)
watch(
  () => props.moved,
  (value) => {
    isMoved.value = value
  }
)

watch(
  () => props.resize,
  (value) => {
    isResize.value = value
  }
)

watch(
  () => props.reset,
  (value) => {
    isReset.value = value
    resetValue(value)
  }
)

watch(
  () => props.fixedSize,
  (value) => {
    fixedRect.value.height = `${value?.height}`
  },
  { deep: true }
)

watch(
  () => props.variableSize,
  (value) => {
    changeVariableSize(value)
  },
  { deep: true }
)

function changeVariableSize(value?: VariableSize) {
  variableRect.value.width = value?.width || 400
  variableRect.value.minWidth = value?.minWidth || 300
  variableRect.value.maxWidth = value?.maxWidth || 600
  onResetSize()
}

//------------------------------------------------------------------------------------------------------------
//computed
//------------------------------------------------------------------------------------------------------------
/*
  const counter: Ref<number> = useState('counter', () => 500)

  // computedによりcounter変数の監視が行われる
  const doubleCount = computed(() => {
    return counter.value * 2
  })
  */
//------------------------------------------------------------------------------------------------------------
// エミット
// 値を親に送信する時に使う
// default（v-model）の場合、modelValueだが色々やるので、別名にする
// :value="hoge" @update.value=(onHoge($event)) みたいにする
//------------------------------------------------------------------------------------------------------------
const emits = defineEmits<{ (e: 'update:close', item: boolean): void }>()

const isOpen = ref(props.switcher.opened)
function onClose() {
  isOpen.value = false
  props.switcher.opened = false
  emits('update:close', false)
}

//------------------------------------------------------------------------------------------------------------
// メソッド
//------------------------------------------------------------------------------------------------------------
interface position {
  x: number
  y: number
}

const startPos: Ref<position> = ref({ x: 0, y: 0 })
const expanderStartPos: Ref<position> = ref({ x: 0, y: 0 })
const expanderPos: Ref<position> = ref({ x: 0, y: 0 })
const activeRectLevel = ref(props.level)
/**
 * タイトルバーをダウン
 * @param e
 */
function onMoveStart(e: MouseEvent) {
  if (isFixed.value || !isMoved.value) return
  // 移動したら、位置を永続的に保存する
  startPos.value.x = e.offsetX
  startPos.value.y = e.offsetY
  window.addEventListener('mousemove', onMouseMove, { passive: true })
  window.addEventListener('mouseup', onMouseUp)
}

function onMouseMove(e: MouseEvent) {
  winSize.value.x = e.clientX - startPos.value.x - activeRect.value.left
  winSize.value.y = e.clientY - startPos.value.y - activeRect.value.top
  activeRectCheck(e)
}

function onMouseUp(e: MouseEvent) {
  window.removeEventListener('mousemove', onMouseMove)
  window.removeEventListener('mouseup', onMouseUp)
}

/**
 * エキスパンダーをダウン
 * @param e
 */
function onResizeStart(e: MouseEvent) {
  // サイズを動かしたら、永続的に保存する
  expanderStartPos.value.x = e.offsetX
  expanderStartPos.value.y = e.offsetY
  window.addEventListener('mousemove', onResizeMove, { passive: true })
  window.addEventListener('mouseup', onResizeUp)
}

function onResizeMove(e: MouseEvent) {
  let x = e.clientX
  let y = e.clientY
  const bt_sx = 32 - 3
  if (activeRect.value.left + activeRect.value.width + expanderStartPos.value.x - bt_sx - 4 < e.clientX) {
    x = activeRect.value.left + activeRect.value.width + expanderStartPos.value.x - bt_sx - 4
  }
  const bt_sy = 32 - 4 + 4
  if (activeRect.value.top + activeRect.value.height + expanderStartPos.value.y - bt_sy - 4 < e.clientY) {
    y = activeRect.value.top + activeRect.value.height + expanderStartPos.value.y - bt_sy - 4
  }

  expanderPos.value.x = x - expanderStartPos.value.x - activeRect.value.left
  expanderPos.value.y = y - expanderStartPos.value.y - activeRect.value.top
  //サイズ設定
  winSize.value.width = expanderPos.value.x - winSize.value.x + bt_sx
  winSize.value.height = expanderPos.value.y - winSize.value.y + bt_sy

  /*
    if (props.small) {
      winSize.value.height -= 24
    }
    */
  sizeCheck()
  activeRectCheck()
}

function onResizeUp(e: MouseEvent) {
  window.removeEventListener('mousemove', onResizeMove)
  window.removeEventListener('mouseup', onResizeUp)
}

function sizeCheck() {
  //最小最大チェック
  // console.log(winSize.value.width, variableRect.value.minWidth, variableRect.value.maxWidth)
  if (winSize.value.width < variableRect.value.minWidth) winSize.value.width = variableRect.value.minWidth
  if (winSize.value.height < variableRect.value.minHeight) winSize.value.height = variableRect.value.minHeight
  if (winSize.value.width > variableRect.value.maxWidth) winSize.value.width = variableRect.value.maxWidth
  if (winSize.value.height > variableRect.value.maxHeight) winSize.value.height = variableRect.value.maxHeight
}

function onWindowResize() {
  transitionAll.value = false
  activeRectCheck()
}

function onResetSize() {
  resetValue(true)
  activeRectCheck()
  window.addEventListener('resize', onWindowResize, { passive: true })
}

/**
 * 可動領域チェック
 * ブラウザWindowのサイズが変わった時、
 * モーダルウィンドウのサイズが変わった時
 * グローバル、ローカルメニューが開閉された時
 * をwatchして、呼び出す
 */
function activeRectCheck(e?: MouseEvent) {
  activeRect.value = useActiveRectNum(activeRectLevel.value)

  if (!props.fixed) {
    const target = e?.target as HTMLInputElement
    //右下チェック
    if (winSize.value.x + winSize.value.width > activeRect.value.width - 4) {
      winSize.value.x = activeRect.value.width - winSize.value.width - 4
      if (e && target?.className === 'Title') startPos.value.x = e.offsetX
    }

    if (winSize.value.x < 0) {
      winSize.value.x = 0
      if (e && target?.className === 'Title') startPos.value.x = e.offsetX
    }

    if (winSize.value.y + winSize.value.height > activeRect.value.height - 4) {
      winSize.value.y = activeRect.value.height - winSize.value.height - 4
      if (e && target?.className === 'Title') startPos.value.y = e.offsetY
    }
    if (winSize.value.y < 0) {
      winSize.value.y = 0
      if (e && target?.className === 'Title') startPos.value.y = e.offsetY
    }
    // 位置を調整した後で、さらにサイズの調整
    if (winSize.value.x + winSize.value.width > activeRect.value.width - 4) {
      winSize.value.width = activeRect.value.width - winSize.value.x - 4
      if (winSize.value.width < variableRect.value.minWidth) winSize.value.width = variableRect.value.minWidth
    }
    if (winSize.value.y + winSize.value.height > activeRect.value.height - 4) {
      winSize.value.height = activeRect.value.height - winSize.value.y - 4
      if (winSize.value.height < variableRect.value.minHeight) winSize.value.height = variableRect.value.minHeight
    }
  }

  modalSetting.value[winSize.value.name] = winSize.value
}

function resetValue(value: boolean) {
  activeRect.value = useActiveRectNum(activeRectLevel.value)
  if (value) {
    if (variableRect.value.justify === 'center') {
      winSize.value.x = (activeRect.value.width - variableRect.value.width) / 2
    } else {
      winSize.value.x = variableRect.value.x
    }
    if (variableRect.value.align === 'center') {
      winSize.value.y = (activeRect.value.height - variableRect.value.height) / 2
    } else {
      winSize.value.y = variableRect.value.y
    }
    winSize.value.width = variableRect.value.width
    winSize.value.height = variableRect.value.height
  }
  // console.log(winSize.value)
}
</script>

<style scoped>
.ActiveRect {
  position: absolute;
  background: rgba(0, 0, 0, 0.6);
  transition: left 0.2s, top 0.2s;
  overflow: hidden;
  pointer-events: auto;
}

.Modeless {
  background: rgba(0, 0, 0, 0);
  pointer-events: none;
}

.transitionAll {
  transition: all 0.2s;
}

.ModalWindow {
  width: 500px;
  height: 500px;
  box-shadow: 0 1px 4px 0 rgba(25, 25, 25, 0.4) !important;
  background-color: rgba(var(--r-color-color));
  border-radius: 5px;
  overflow: hidden;
  pointer-events: auto;
}

.Title {
  position: relative;
  background: rgba(var(--r-color-primary), 1);
  color: rgb(var(--r-color-reverse));
  font-size: 14px;
  width: 100%;
  height: 40px;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  cursor: pointer;
}
.Title .TitleInner {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 10px 20px 0 10px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.Fixed {
  position: relative;
  cursor: auto !important;
  background-color: rgba(var(--r-color-surface), 0.85);
  color: rgba(var(--r-color-color), 1);
}

.Content {
  position: relative;
  width: 100%;
  height: calc(100% - 40px);
  padding-bottom: 14px;
}
.Content::before {
  content: "";
  position: absolute;
  top: 0px;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(var(--r-color-surface), 0.96);
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 5px;
  z-index: 0;
}
.Content .ContentScroll {
  position: relative;
  width: 100%;
  height: 100%;
}
.Content .ContentScroll .ContentInner {
  position: relative;
  width: 100%;
  min-height: 100%;
  font-size: 12px;
  padding: 10px;
  color: rgba(var(--r-color-color), 1);
}

th {
  text-align: left;
  vertical-align: top;
}

.CloseButton {
  position: absolute !important;
  right: 4px;
  top: 4px;
}

.ExpanderButton {
  position: absolute !important;
  right: -3px !important;
  bottom: -4px !important;
}

.RestoreWindow {
  position: absolute;
  right: 32px;
  top: 4px;
  width: 24px;
  height: 24px;
}

.HeaderSlot {
  position: absolute;
  right: 70px;
  top: 0px;
  height: 40px;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  z-index: 1;
}

.Small .Title {
  height: 28px;
  font-size: 12px;
}
.Small .Title .TitleInner {
  padding: 6px 20px 0 10px;
}
.Small .Content {
  height: calc(100% - 28px);
}
.Small .CloseButton {
  right: 1px !important;
  top: -1px !important;
}
.Small .RestoreWindow {
  right: 28px;
  top: -1px;
}
.Small .HeaderSlot {
  height: 28px;
}
</style>
